// bron: https://css-tricks.com/scroll-drawing/
// Get a reference to the <path>
var path = document.querySelector('#star-path');

// Get length of path... ~577px in this case
var pathLength = path.getTotalLength();

// Make very long dashes (the length of the path itself)
path.style.strokeDasharray = pathLength + ' ' + pathLength;

// Offset the dashes so the it appears hidden entirely
path.style.strokeDashoffset = pathLength;

// Jake Archibald says so
// https://jakearchibald.com/2013/animated-line-drawing-svg/
path.getBoundingClientRect();

// When the page scrolls...
window.addEventListener("scroll", function (e) {

    // What % down is it? 
    // https://stackoverflow.com/questions/2387136/cross-browser-method-to-determine-vertical-scroll-percentage-in-javascript/2387222#2387222
    // Had to try three or four differnet methods here. Kind of a cross-browser nightmare.
    var scrollPercentage = (document.documentElement.scrollTop + document.body.scrollTop) / (document.documentElement.scrollHeight - document.documentElement.clientHeight);

    // Length to offset the dashes
    var drawLength = pathLength * scrollPercentage;

    // Draw in reverse
    path.style.strokeDashoffset = pathLength - drawLength;

    // When complete, remove the dash array, otherwise shape isn't quite sharp
    // Accounts for fuzzy math
    if (scrollPercentage >= 0.99) {
        path.style.strokeDasharray = "none";

    } else {
        path.style.strokeDasharray = pathLength + ' ' + pathLength;
    }

});


// bron: http://soulwire.github.io/Crystallisation/
// Generated by CoffeeScript 1.4.0
var Line, Polygon, Vertex, crystallisation, gui,
    __slice = [].slice;

Vertex = (function () {

    function Vertex(x, y) {
        this.x = x != null ? x : 0.0;
        this.y = y != null ? y : 0.0;
    }

    Vertex.prototype.distanceSq = function (v) {
        var dx, dy;
        return (dx = v.x - this.x) * dx + (dy = v.y - this.y) * dy;
    };

    Vertex.prototype.distance = function (v) {
        var dx, dy;
        return sqrt((dx = v.x - this.x) * dx + (dy = v.y - this.y) * dy);
    };

    Vertex.prototype.angle = function (v) {
        return atan2(v.y - this.y, v.x - this.x);
    };

    Vertex.prototype.lerp = function (v, f) {
        return new Vertex(this.x + (v.x - this.x) * f, this.y + (v.y - this.y) * f);
    };

    Vertex.prototype.clone = function () {
        return new Vertex(this.x, this.y);
    };

    return Vertex;

})();

Line = (function () {

    function Line(start, end) {
        this.start = start;
        this.end = end;
    }

    return Line;

})();

Polygon = (function () {

    function Polygon() {
        var vertices;
        vertices = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        this.vertices = vertices;
        this.generation = 0;
        this.unique = [];
    }

    Polygon.prototype.subdivide = function (randomness, opposite) {
        var i1, i2, j1, j2, l1, l2, nv, p1, p2, v1, v2, _ref;
        if (randomness == null) {
            randomness = 0.0;
        }
        if (opposite == null) {
            opposite = 0.5;
        }
        nv = this.vertices.length;
        i1 = ~~random(nv);
        i2 = random() < opposite ? ~~(i1 + nv / 2) % nv : ~~random(nv);
        while (i2 === i1) {
            i2 = ~~random(nv);
        }
        l1 = 0.5 + random(randomness * -0.5, randomness * 0.5);
        l2 = 0.5 + random(randomness * -0.5, randomness * 0.5);
        v1 = this.vertices[i1].lerp(this.vertices[(i1 + 1) % nv], l1);
        v2 = this.vertices[i2].lerp(this.vertices[(i2 + 1) % nv], l2);
        _ref = [i1, i2], j1 = _ref[0], j2 = _ref[1];
        p1 = new Polygon(v1);
        while (j1 !== i2) {
            p1.vertices.push(this.vertices[j1 = (j1 + 1) % nv]);
        }
        p1.vertices.push(v2);
        p2 = new Polygon(v2);
        while (j2 !== i1) {
            p2.vertices.push(this.vertices[j2 = (j2 + 1) % nv]);
        }
        p2.vertices.push(v1);
        p1.generation = this.generation + 1;
        p2.generation = this.generation + 1;
        p1.unique.push(new Line(v1, v2));
        return [p1, p2];
    };

    Polygon.prototype.centroid = function () {
        var cx, cy, vertex, _i, _len, _ref;
        cx = cy = 0.0;
        _ref = this.vertices;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            vertex = _ref[_i];
            cx += vertex.x;
            cy += vertex.y;
        }
        return new Vertex(cx / this.vertices.length, cy / this.vertices.length);
    };

    Polygon.prototype.minAngle = function () {
        var A, B, C, a, b, c, index, len, next, prev, rule, val, vertex, _i, _len, _ref;
        rule = function (a, b, c) {
            return Math.acos((a * a + b * b - c * c) / (2 * a * b));
        };
        val = Number.MAX_VALUE;
        len = this.vertices.length;
        _ref = this.vertices;
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
            vertex = _ref[index];
            prev = this.vertices[(index - 1 + len) % len];
            next = this.vertices[(index + 1 + len) % len];
            a = prev.distance(vertex);
            b = next.distance(vertex);
            c = next.distance(prev);
            A = rule(b, c, a);
            B = rule(c, a, b);
            C = Math.PI - A - B;
            val = min(val, C);
        }
        return val;
    };

    Polygon.prototype.minSide = function () {
        var prev, side, vertex, _i, _len, _ref;
        side = Number.MAX_VALUE;
        prev = this.vertices[this.vertices.length - 1];
        _ref = this.vertices;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            vertex = _ref[_i];
            side = min(side, vertex.distanceSq(prev));
            prev = vertex;
        }
        return sqrt(side);
    };

    Polygon.prototype.perimeter = function () {
        var result;
        result = this.vertices[0].distance(this.vertices[this.vertices.length - 1]);
        this.vertices.reduce(function (a, b) {
            result += a.distance(b);
            return a = b;
        });
        return result;
    };

    Polygon.prototype.draw = function (ctx) {
        var vertex, _i, _len, _ref;
        ctx.fillStyle = '#fff';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        vertex = this.vertices[0];
        ctx.moveTo(vertex.x, vertex.y);
        _ref = this.vertices;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            vertex = _ref[_i];
            ctx.lineTo(vertex.x, vertex.y);
        }
        ctx.closePath();
        ctx.fill();
        return ctx.stroke();
    };

    return Polygon;

})();

crystallisation = Sketch.create({
    settings: {
        iterations: 50,
        randomness: 0.25,
        opposite: 0.1,
        minAngle: 0.4,
        minSide: 2
    },
    polygons: [],
    lines: [],
    container: document.getElementById('container'),
    autoclear: false,
    interval: 1,
    setup: function () {
        return this.reset();
    },
    step: function () {
        var drop, index, line, slice, slices, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref;
        index = ~~random(this.polygons.length - 1);
        slices = this.polygons[index].subdivide(this.settings.randomness, this.settings.opposite);
        for (_i = 0, _len = slices.length; _i < _len; _i++) {
            slice = slices[_i];
            if (slice.minAngle() < this.settings.minAngle) {
                drop = true;
                break;
            }
        }
        for (_j = 0, _len1 = slices.length; _j < _len1; _j++) {
            slice = slices[_j];
            if (slice.minSide() < this.settings.minSide) {
                drop = true;
                break;
            }
        }
        if (!(drop != null)) {
            _ref = this.polygons[index].unique;
            for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
                line = _ref[_k];
                this.lines.push(line);
            }
            for (_l = 0, _len3 = slices.length; _l < _len3; _l++) {
                slice = slices[_l];
                this.polygons.push(slice);
                slice.draw(this);
            }
            return this.polygons.splice(index, 1);
        }
    },
    reset: function () {
        var a, b, c, d;
        a = new Vertex(0, 0);
        b = new Vertex(this.width, 0);
        c = new Vertex(this.width, this.height);
        d = new Vertex(0, this.height);
        this.polygons = [new Polygon(a, b, c, d)];
        this.lines = [];
        return this.clear();
    },
    toggle: function () {
        return (this.running ? this.stop : this.start)();
    },
    draw: function () {
        var i, _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.settings.iterations; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            _results.push(this.step());
        }
        return _results;
    },
    save: function () {
        return window.open(this.canvas.toDataURL(), 'subdivide', "top=20,left=20,width=" + this.width + ",height=" + this.height);
    }
});

gui = new dat.GUI();

gui.add(crystallisation.settings, 'minSide').min(0).max(100).name('min side length');

gui.add(crystallisation.settings, 'minAngle').min(0.0).max(1.2).step(0.01).name('min angle (rad)');

gui.add(crystallisation.settings, 'iterations').min(1).max(100);

gui.add(crystallisation.settings, 'randomness').min(0.0).max(1.0).step(0.01);

gui.add(crystallisation.settings, 'opposite').min(0.0).max(1.0).step(0.01).name('opposite sides');

gui.add(crystallisation, 'toggle').name('start / stop');

gui.add(crystallisation, 'reset').name('reset polygons');

gui.add(crystallisation, 'clear').name('clear canvas');

gui.add(crystallisation, 'save').name('save');